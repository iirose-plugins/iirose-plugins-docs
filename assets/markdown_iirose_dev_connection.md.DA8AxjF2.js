import{_ as i,z as a,m as e,ap as t}from"./chunks/framework.Dj65yJjF.js";const k=JSON.parse('{"title":"连接服务器","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/iirose/dev/connection.md","filePath":"markdown/iirose/dev/connection.md","lastUpdated":1762619484000}'),n={name:"markdown/iirose/dev/connection.md"};function o(l,s,p,h,r,c){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="连接服务器" tabindex="-1">连接服务器 <a class="header-anchor" href="#连接服务器" aria-label="Permalink to &quot;连接服务器&quot;">​</a></h1><p>在与 IIROSE 服务器进行任何交互之前，客户端必须首先建立一个稳定的 WebSocket 连接。</p><p>本文档将详细说明如何选择最佳服务器并完成连接。</p><h2 id="_1-探测可用服务器" tabindex="-1">1. 探测可用服务器 <a class="header-anchor" href="#_1-探测可用服务器" aria-label="Permalink to &quot;1. 探测可用服务器&quot;">​</a></h2><p>IIROSE 平台拥有多个接入点，为了获得最佳的通信体验，推荐的流程是探测所有已知的服务器地址，并选择延迟最低的一个。</p><h3 id="服务器列表" tabindex="-1">服务器列表 <a class="header-anchor" href="#服务器列表" aria-label="Permalink to &quot;服务器列表&quot;">​</a></h3><p>已知的服务器接入点前缀包括：</p><ul><li><code>m1</code></li><li><code>m2</code></li><li><code>m8</code></li><li><code>m9</code></li><li><code>m</code> (通常解析为 <code>www</code>)</li></ul><h3 id="连接地址格式" tabindex="-1">连接地址格式 <a class="header-anchor" href="#连接地址格式" aria-label="Permalink to &quot;连接地址格式&quot;">​</a></h3><p>每个前缀都对应一个 WebSocket 地址，格式如下：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>wss://{服务器前缀}.iirose.com:8778</span></span></code></pre></div><p>例如：<code>wss://m1.iirose.com:8778</code></p><h3 id="探测方法" tabindex="-1">探测方法 <a class="header-anchor" href="#探测方法" aria-label="Permalink to &quot;探测方法&quot;">​</a></h3><p>客户端应并行地尝试与上述列表中的所有服务器建立 WebSocket 连接，并测量从发起连接到成功 <code>open</code> 事件触发所花费的时间。</p><p>选择耗时最短（即延迟最低）的服务器作为本次会话的通信地址。</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>如果所有服务器都无法在设定的超时时间（例如30秒）内成功连接，客户端应等待一段时间后（例如5秒）进行重试，直到找到可用的服务器。</p></div><h2 id="_2-建立-websocket-连接" tabindex="-1">2. 建立 WebSocket 连接 <a class="header-anchor" href="#_2-建立-websocket-连接" aria-label="Permalink to &quot;2. 建立 WebSocket 连接&quot;">​</a></h2><p>选定最佳服务器地址后，即可正式创建 WebSocket 实例。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> targetUrl</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;wss://m1.iirose.com:8778&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 假设 m1 是最快的服务器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> socket</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">targetUrl</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-light-font-style:inherit;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 必须将二进制类型设置为 arraybuffer 以正确处理压缩数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">socket</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">binaryType</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;arraybuffer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre></div><h2 id="_3-数据压缩" tabindex="-1">3. 数据压缩 <a class="header-anchor" href="#_3-数据压缩" aria-label="Permalink to &quot;3. 数据压缩&quot;">​</a></h2><p>IIROSE 的通信协议使用 <code>gzip</code> 压缩以减少网络负载。</p><ul><li><p><strong>发送时</strong>：当要发送的报文（UTF-8字符串）长度超过 256 字节时，应先对其进行 <code>gzip</code> 压缩。然后，在压缩后的数据（<code>Buffer</code>）前添加一个字节 <code>0x01</code> 作为压缩标识，最后发送这个新的二进制数据包。如果未超过长度，则直接发送原始的 UTF-8 字节流。</p></li><li><p><strong>接收时</strong>：当收到一个二进制数据包时，首先检查第一个字节。如果第一个字节是 <code>0x01</code>，则说明后续数据是经过 <code>gzip</code> 压缩的，需要先解压才能得到原始的 JSON 字符串。如果不是，则直接将整个数据包按 <code>UTF-8</code> 解码。</p></li></ul><div class="warning custom-block"><p class="custom-block-title">重要</p><p><strong>正确处理数据压缩</strong> 是保证通信正常的 <strong>关键</strong>。</p></div><p>连接成功建立后，下一步就是发送登录报文。</p>`,24)])])}const g=i(n,[["render",o]]);export{k as __pageData,g as default};
